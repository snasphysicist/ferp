package proxy

import (
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/snasphysicist/ferp/v2/pkg/log"
)

// Remapper constructs the downstream URL from the incoming path
type Remapper struct {
	Protocol string
	Host     string
	Port     uint16
	Base     string
	Mapper   pathRewriter
}

// pathRewriter converts the incoming path (at which this proxy received the request)
// to the downstream path (where the request will be made on the proxied service)
type pathRewriter func(string) string

// ForwardRequest forwards the incoming request to the configured downstream
// and writes out the received reponse to the outgoing response
func (r Remapper) ForwardRequest(w http.ResponseWriter, req *http.Request) {
	url := r.makeURL(req.URL.Path)
	dReq, err := http.NewRequest(req.Method, url, req.Body)
	if err != nil {
		log.Errorf("Failed to construct downstream request: %s", err)
		sendInternalErrorResponse(w)
		return
	}
	transferRequestHeaders(req, dReq)
	res, err := (&http.Client{}).Do(dReq)
	if err != nil {
		log.Errorf("Failed to send downstream request: %s", err)
		sendInternalErrorResponse(w)
		return
	}
	transferResponseHeaders(res, w)
	w.WriteHeader(res.StatusCode)
	_, err = io.Copy(w, res.Body)
	if err != nil {
		log.Errorf("Failed to forward response body: %s", err)
		return
	}
	log.Infof("Successfully proxied request from %s to %#v",
		req.URL.String(), dReq.URL.String())
}

// makeURL contructs the URL to which to make the downstream request
// from the configured host/etc.. plus the passed incoming path
// TODO: check ? query parameters and # fragments
func (r Remapper) makeURL(incoming string) string {
	suffix := r.Mapper(incoming)
	base := strings.TrimLeft(r.Base, "/")
	if suffix == "" {
		url := fmt.Sprintf("%s://%s:%d/%s", r.Protocol, r.Host, r.Port, base)
		log.Infof("No suffix, returning %s (base '%s')", url, base)
		return url
	}
	suffix = strings.TrimLeft(suffix, "/")
	base = strings.TrimRight(base, "/")
	if base != "" {
		base = fmt.Sprintf("%s/", base)
	}
	url := fmt.Sprintf("%s://%s:%d/%s%s", r.Protocol, r.Host, r.Port, base, suffix)
	log.Infof("Had suffix, returning %s (base '%s', suffix '%s')", url, base, suffix)
	return url
}

// sendInternal sends an error response when something goes wrong in the proxy itself
func sendInternalErrorResponse(w http.ResponseWriter) {
	w.WriteHeader(http.StatusInternalServerError)
	_, err := w.Write([]byte(internalErrorMessage))
	if err != nil {
		log.Errorf("Failed to write error response body: %s", err)
	}
}

// transferRequestHeaders copies all headers from "from" to "to"
// except for content-length, which must be autogenerated
// TODO: there are probably other headers we shouldn't copy
func transferRequestHeaders(from *http.Request, to *http.Request) {
	for k, values := range from.Header {
		if k == "content-length" {
			break
		}
		for _, value := range values {
			to.Header.Add(k, value)
		}
	}
}

// transferRequestHeaders copies all headers from "from" to "to"
// except for content-length, which must be autogenerated
// TODO: there are probably other headers we shouldn't copy
func transferResponseHeaders(from *http.Response, to http.ResponseWriter) {
	for k, values := range from.Header {
		if k == "content-length" {
			break
		}
		for _, value := range values {
			to.Header().Add(k, value)
		}
	}
}

// internalErrorMessage is a standard non-implementation detail leaking error message
const internalErrorMessage = "500: something went wrong"
